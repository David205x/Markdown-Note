# L10 用户级线程

### 线程与进程
- 进程 = 资源 + 指令执行序列
- 将资源和指令分开执行
- 一个资源+多个指令执行序列
##### 线程
- 线程是同一个地址空间内启动并交替执行的多个程序。
- 交替执行的多个线程可以由操作系统管理，也可以由用户程序自己管理。
- 一个进程可以有一个或多个线程。
- 资源共享：同一进程中的多个线程将共享该进程中的全部系统资源，如虚拟地址空间，文件描述符和信号处理等等。但有有各自的调用栈和线程本地存储。
- TCB：系统为线程分配一个**线程控制块TCB**（Thread Control Block），将所有用于控制和管理线程的信息记录在线程的控制块中。

### 线程切换
- 线程切换的实质：PC指针改变而映射表不变——指令执行改变而资源不变

### 用户级线程
- 用户程序自己管理的线程对操作系统透明，操作系统完全不知道这些线程的存在，对于内核而言，它们只是一堆单线程进程。这样的线程被称为**用户级线程**（协程）。相应地，由操作系统管理的线程称为**内核级线程**。
##### 用户级线程的切换
- 对于用户级线程来说，切换的本质就是由用户程序自己调用Yield()函数。在某个函数需要等待阻塞时，将PC指针切换到另一个地址，开始执行另一个线程。
##### 用户栈
- 不同的用户级线程拥有各自的用户栈，登记在TCB中。
- 线程切换时，用户栈也要切换
- 两个线程之间混用用户栈，将导致线程内的**普通函数调用**和**用户栈之间切换调用**的混淆，证明了用户栈的必要性
##### Yield函数
- Yield()函数完成的基本工作是找到下一个线程的TCB，然后根据当前线程的TCB和下一个线程的TCB完成用户栈之间的切换。
``` C
void Yield(){
  //esp是CPU中的栈顶指针
  TCB1.esp = esp; //当前线程的栈顶指针被存储到TCB，保护现场
  esp = TCP2.esp; //新线程的栈顶指针加载到CPU
}
```
- Yield函数是用户主动调取的，而Schedule函数完全由操作系统执行，用户不可见。

### 线程切换的局限
- 进程的某个线程进入内核并阻塞（被内核Schedule），将导致所有进程中的所有线程都被阻塞。