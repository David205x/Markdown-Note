## 绪论

- 成绩占比
  - `70%` 期末考核
  - `30%` 平时成绩
    - 随堂测验
    - 签到



## 第一章：引言

- 计算机网络定义
  - 多个独立的计算机通过网络连接
  - 通过一套技术在不同系统间交流
- 分类
  - 按规模分类
    - 个人网
    - 局域网
      - 总线网
      - 环型网
    - 广域网
  - 按传输技术分类
    - 广播式
    - 点对点式

### 网络软件

- 协议层次结构
  - 层次栈/分级栈[^ 每一层目的想上一层提供特定的服务，而把如何实现的服务细节对上一层加以屏蔽]
  - 协议[^ 通信双方就如何进行通信的一种约定]
  - 接口[^ 下层向上层提供那些原语操作和服务]
  - 网络体系结构[^ 层和协议的集合]

- 信息的传递需经历层层打包和解包

- 面向连接&无连接的服务
  - 面向连接的服务[^ Eg: 管道专线连接 ]
  - 无连接服务[^ Eg: 邮政式中转分发]



### 参考模型

- 七层OSI参考模型
  1. 物理层：关注一条通信信道上传输原始比特
  
  2. 链路层：将一个原始的传输设施转变成一条没有漏检传输错误的线路
  
  3. 网络层：控制子网的运行
  
  4. 运输层：接受来自上一层的数据，必要时把这些数据分割成较小的单元，

     ​				然把这些数据单元传递给网络层，并且确保这些数据单元正确到达另一端
  
     ​				真正的端到端的层
  
  5. 会话层：允许不同机器上的用户建立会话
  
  6. 表示层：关注所传递信息的语法和语义
  
  7. 应用层：包含了用户通常需要的各种各样的协议
  
- TCP/IP参考模型

  1. 链路层(略)：主机与传输线路之间的一个接口，描述链路需完成什么才能满足无连接的互联网络层的需求

  2. 互联网层：将整个网络体系结构贯穿在一起的关键层

     > IP[^ 定义了官方的数据包格式和协议]，ICMP[^ 因特网控制报文协议]

  3. 传输层：允许源主机和目标主机上的对等实体进行对话

     > TCP[^ 可靠的，面向连接的协议]，UDP[^ 不可靠的，面向无连接的协议]

  4. 应用层：包含所有高层协议

     > TELNET，FTP，SMTP，HTTP

- OSI和TCP/IP参考模型的比较
  - service interface protocol
  - OSI：影响力强概念明晰；被政治局势影响产生
  - TCP/IP：成功且运转良好的协议，并成为标准；实际指导产生的协议，分层模糊易混淆

- Hybird Model[^ 现今在用的模型]

### 网络实例

- Internet
  - 大量网络的集合
  - 使用特定公共协议并提供特定公共服务
  - 前身APRANET：分组交换
- Ethernet
  - 总线式(相对于广播式的传播方式)
  - 小范围
- Wireless Networks

- 网络有影响力的组织
  - ISO[^ 国际标准化组织]，ITU[^ ]，IEEE[^ ]，ETF[^ ]，W3C[^ ]

### 1.9章总结



## 第二章：物理层[^ 比特]

> 物理层<u>**比特**</u> - 链路层<u>帧</u>

### 2.6.5交换

- 电路交换[^ 基于实际端到端物理路径的信息交换]

  > 保证服务，可能浪费资源

- 包交换/分组交换[^ 路由器使用储存-转发技术，由于无固定路径，到达的秩序可能出现混乱]

  > 不保证服务，不会浪费资源

  - 规定数据包的大小：确保不发生霸占传输线路的问题
  - 没为传输数据预留带宽：排队延迟




## 第三章：数据链路层[^ 帧]

> 物理层<u>比特</u> - 链路层**<u>帧</u>** - 网络层<u>包</u>

### 3.1 设计问题

- 主要功能
  - 给网络层提供服务接口
  - 处理传输错误
  - 调节数据流，适应不同速设备不被淹没
- (数据)帧的构成：帧头，有效载荷，帧尾

#### 3.1.1 提供给网络层的服务

- 无确认的无连接：源机器向目标机器发送独立的帧，目标机器并不对这些帧进行确认

  - 特点

    - 不需建立逻辑连接，不用释放逻辑连接
    - 不试图检测丢帧或试图恢复丢失帧

  - 用于错误率低的场合，靠上层恢复；实时通信，延迟比受损更严重

    > Ethernet

- 有确认的无连接：不使用逻辑连接，但每一帧需独立确认

  - 用于不可靠的信道

    > 802.11

- 有确认的有连接：建立逻辑连接，编号每一帧并确认收到

  - 特点
    - 最复杂服务：建立/维护/释放连接，初始化/释放变量和计数器
    - 所有帧只被接收一次，且按照正确顺序接收

#### 3.1.2 成帧[^ 为方便纠错拆分比特流为帧并附上校验]

- 字节计数法[^ 利用头部中的一个字段来表示该帧中字符数]

  - 问题
    - 因一个传输错误而混乱，造成此起后续所有数据无法被正确识别
    - 且接收方无法得知距离开始处多少字节

- 字节填充的标志字节法[^ 用标志字节作为帧的起始和结束分界符]

  - 解决：出错后的重新同步问题：搜索两个标志字节以获取当前帧结尾和下一帧起始

  - 问题
    - 标志字节`FLAG` `ESC`出现在数据中时影响帧的分界
      - 字节填充技术：前面再添加转义字节`ESC`
    - 只能使用8比特的字节

- 比特填充的标志比特法[^ 在比特级完成帧的划分，帧可包含任意大小单元组成的二进制比特数。开始结束由特殊比特模式决定]

  - 用填充比特的方法避免标志比特在内容中出现(标志比特连6个1，则内容每连续5个1补1个0)
  - 解决：只能使用8比特的字节为单元

  > USB

- 物理层编码违禁法(略)

- 差错控制[^ 修复收到的错误]

  > - 要求错误被接收方发现

#### 3.1.3 流量控制[^ 处理不同速设备信息间传输堵塞]

- 基于反馈的流量控制
- 基于速率的流量控制

### 3.2 错误检测和纠错

### 3.3 基本数据链路层协议

#### 3.3.1 乌托邦式的单工协议[^ 不考虑任何出错的情况，仅单向传输]

- 收发双方**总处于准备就绪**状态，数据**处理时间不计**，**可用缓存无穷大**，链路层通信信道**永不损坏帧或丢帧**

```C++
void sender1(void) {
    frame s;
    packet buffer;
    while(true) {
        网络层接收数据储存至buffer;
        转buffer中信息为frame;
        把frame发送给物理层;
    }
}
void recerver1(void) {
    frame r;
    event_type event;
    while(true) {
        等事件触发发生;
        接收并将硬件缓冲区的bit转为frame;
        解析frame转化并传递给网络层;
    }
}
```

#### 3.3.2 无措信道上的单工停-等式协议[^ 考虑接收方可能被高速发送方的帧淹没情况]

- 建立强大接收器
- 接收方传递数据包至网络层后发送反馈信息(哑帧)

#### 3.3.3 有错信道上的单工停-等式协议[^ 考虑常规 出错帧 损坏帧 丢失帧情况]